package endpoint

import (
	"fmt"
	"strings"

	"github.com/RussellLuo/kok/gen/util/generator"
	"github.com/RussellLuo/kok/gen/util/openapi"
	"github.com/RussellLuo/kok/gen/util/reflector"
	"github.com/RussellLuo/kok/pkg/caseconv"
)

var (
	template = `// Code generated by kok; DO NOT EDIT.
// github.com/RussellLuo/kok

package {{.Result.PkgName}}

import (
	"github.com/RussellLuo/valiadting/v2"
	"github.com/go-kit/kit/endpoint"

	{{- range .Result.Imports}}
	"{{.}}"
	{{- end }}
)

{{- $srcPkgPrefix := .Result.SrcPkgPrefix}}
{{- $interfaceName := .Result.Interface.Name}}

{{- range .DocMethods}}

{{- $params := nonCtxParams .Params .Op.Request.Params}}
{{- $hasCtxParam := hasCtxParam .Params}}

{{- if $params}}
type {{.Name}}Request struct {
	{{- range $params}}
	{{title .Name}} {{.Type}} {{addTag .Alias .Type}}
	{{- end}}
}

// Validate{{.Name}}Request creates a validator for {{.Name}}Request.
func Validate{{.Name}}Request(newSchema func({{addAsterisks .Name}}Request) validating.Schema) httpoption.Validator {
	return httpoption.FuncValidator(func(value interface{}) error {
		req := value.({{addAsterisks .Name}}Request)
		schema := newSchema(req)
		errs := validating.Validate(schema)
		if len(errs) == 0 {
			return nil
		}
		return werror.Wrap(gcode.ErrInvalidArgument, errs)
	})
}
{{- end}}

{{if .Returns -}}

type {{.Name}}Response struct {
	{{- range .Returns}}
	{{title .Name}} {{.Type}} {{addTag .Name .Type}}
	{{- end}}
}

{{- $respBodyField := .Op.SuccessResponse.BodyField}}
{{- if $respBodyField}}
func (r {{addAsterisks .Name}}Response) Body() interface{} { return r.{{title $respBodyField}} }
{{- else}}
func (r {{addAsterisks .Name}}Response) Body() interface{} { return r }
{{- end}}

{{- end}} {{/* if .Returns */}}

{{- $errParamName := getErrParamName .Returns}}
{{- if $errParamName}}
// Failed implements endpoint.Failer.
func (r {{addAsterisks .Name}}Response) Failed() error { return r.{{title $errParamName}} }
{{- end}}

// MakeEndpointOf{{.Name}} creates the endpoint for s.{{.Name}}.
func MakeEndpointOf{{.Name}}(s {{$srcPkgPrefix}}{{$interfaceName}}) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (interface{}, error) {
		{{- if $params}}
		req := request.({{addAsterisks .Name}}Request)
		{{- end}}

		{{- if .Returns}}
		{{joinName .Returns ", "}} := s.{{.Name}}(
			{{- if $hasCtxParam}}
			ctx,
			{{- end}}
			{{- range $params}}
			req.{{title .Name}} {{- if .Variadic}}...{{end}},
			{{- end}}
		)
		return {{addAmpersand .Name}}Response{
			{{- range .Returns}}
			{{title .Name}}: {{.Name}},
			{{- end}}
		}, nil
		{{- else}}
		s.{{.Name}}(
			{{- if $hasCtxParam}}
			ctx,
			{{- end}}
			{{- range $params}}
			req.{{title .Name}} {{- if .Variadic}}...{{end}},
			{{- end}}
		)
		return nil, nil
		{{- end}} {{/* End of if .Returns */}}
	}
}

{{- end}} {{/* End of range .DocMethods */}}
`
)

type Options struct {
	SchemaPtr         bool
	SchemaTag         string
	TagKeyToSnakeCase bool
	Formatted         bool
}

type Generator struct {
	opts *Options
}

func New(opts *Options) *Generator {
	return &Generator{opts: opts}
}

func (g *Generator) Generate(result *reflector.Result, spec *openapi.Specification) ([]byte, error) {
	operationMap := make(map[string]*openapi.Operation)
	for _, op := range spec.Operations {
		operationMap[op.Name] = op
	}

	type MethodWithOp struct {
		*reflector.Method
		Op *openapi.Operation
	}

	type ParamWithAlias struct {
		*reflector.Param
		Alias string
	}

	var docMethods []MethodWithOp
	for _, m := range result.Interface.Methods {
		if op, ok := operationMap[m.Name]; ok {
			docMethods = append(docMethods, MethodWithOp{
				Method: m,
				Op:     op,
			})
		}
	}

	data := struct {
		Result     *reflector.Result
		DocMethods []MethodWithOp
	}{
		Result:     result,
		DocMethods: docMethods,
	}

	return generator.Generate(template, data, generator.Options{
		Funcs: map[string]interface{}{
			"title": strings.Title,
			"nonCtxParams": func(params []*reflector.Param, reqParams []*openapi.Param) (out []ParamWithAlias) {
				nameToAlias := make(map[string]string)
				for _, p := range reqParams {
					if p.In == openapi.InBody {
						// Only parameters in body are supported for changing tag-name by alias.
						nameToAlias[p.Name] = p.Alias
					}
				}

				for _, p := range params {
					if p.Type != "context.Context" {
						out = append(out, ParamWithAlias{
							Param: p,
							Alias: nameToAlias[p.Name],
						})
					}
				}
				return
			},
			"hasCtxParam": func(params []*reflector.Param) bool {
				for _, p := range params {
					if p.Type == "context.Context" {
						return true
					}
				}
				return false
			},
			"getErrParamName": func(params []*reflector.Param) string {
				for _, p := range params {
					if p.Type == "error" {
						return p.Name
					}
				}
				return ""
			},
			"joinName": func(returns []*reflector.Param, sep string) string {
				var names []string
				for _, r := range returns {
					names = append(names, r.Name)
				}
				return strings.Join(names, sep)
			},
			"addAsterisks": func(name string) string {
				if g.opts.SchemaPtr {
					return "*" + name
				}
				return name
			},
			"addAmpersand": func(name string) string {
				if g.opts.SchemaPtr {
					return "&" + name
				}
				return name
			},
			"addTag": func(name, typ string) string {
				if g.opts.SchemaTag == "" {
					return ""
				}

				if name == "" || typ == "error" {
					name = "-"
				} else if g.opts.TagKeyToSnakeCase {
					name = caseconv.ToSnakeCase(name)
				}

				return fmt.Sprintf("`%s:\"%s\"`", g.opts.SchemaTag, name)
			},
		},
		Formatted: g.opts.Formatted,
	})
}
