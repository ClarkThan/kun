package oasv2

import (
	"fmt"
	"strings"

	"github.com/RussellLuo/kok/gen/util/generator"
	"github.com/RussellLuo/kok/gen/util/openapi"
	"github.com/RussellLuo/kok/gen/util/reflector"
	"github.com/RussellLuo/kok/pkg/caseconv"
)

var (
	template = `// Code generated by kok; DO NOT EDIT.
// github.com/RussellLuo/kok

package {{.Result.PkgName}}

import (
	"bufio"
	"bytes"
	"fmt"
	"net/http"
	"net/http/httptest"
	"reflect"
	"strings"
	"text/template"

	chimiddleware "github.com/go-chi/chi/middleware"
	"github.com/RussellLuo/kok/pkg/oasv2"
)

var (
	base = ` + "`" + `swagger: "2.0"
info:
  title: "{{.Spec.Metadata.Title}}"
  version: "{{.Spec.Metadata.Version}}"
  description: "{{.Spec.Metadata.Description}}"
  license:
    name: "MIT"
host: "example.com"
basePath: "{{.Spec.Metadata.BasePath}}"
schemes:
  - "https"
consumes:
  - "application/json"
produces:
  - "application/json"
` + "`" + `

{{- $defaultTags := .Spec.Metadata.DefaultTags}}
{{- $operationsGroupByPattern := operationsGroupByPattern .Spec.Operations}}

	paths = ` + "`" + `
paths:
{{- range $operationsGroupByPattern}}
  {{.Pattern}}:

  {{- range .Operations}}
  {{- $nonCtxParams := nonCtxParams .Request.Params}}
    {{lower .Method}}:
      description: "{{.Description}}"
      operationId: "{{.Name}}"
      {{- $tags := getTags .Tags $defaultTags}}
      {{- if $tags}}
      tags:
        {{- range $tags}}
        - {{.}}
        {{- end -}} {{/* range $tags */}}
      {{- end -}} {{/* if $tags */}}

      {{- $nonCtxNonBodyParams := nonBodyParams $nonCtxParams}}
      {{- if $nonCtxParams}}
      parameters:
        {{- range $nonCtxNonBodyParams}}
        - name: {{.Alias}}
          in: {{.In}}
          required: {{.Required}}
          {{- $type := typeName .AliasType}}
          type: {{$type.Type}}
          {{- if $type.ItemType}}
          items:
            type: {{$type.ItemType}}
          {{- end}}
          description: "{{.Description}}"
        {{- end -}} {{/* range $nonCtxNonBodyParams */}}

        {{- $bodyParams := bodyParams $nonCtxParams}}
        {{- if $bodyParams}}
        - name: body
          in: body
          schema:
            $ref: "#/definitions/{{.Name}}RequestBody"
        {{- end}}
      {{- end -}} {{/* if $nonCtxParams */}}
      %s
  {{- end -}} {{/* range .Operations */}}

{{- end -}} {{/* range $operationsGroupByPattern */}}
` + "`" + `
)

func getResponses(schema oasv2.Schema) []oasv2.OASResponses {
	return []oasv2.OASResponses{
		{{- range $operationsGroupByPattern}}
		{{- range .Operations}}
		oasv2.GetOASResponses(schema, "{{.Name}}", {{.SuccessResponse.StatusCode}}, {{addAmpersand .Name}}Response{}),
		{{- end}} {{/* range .Operations */}}
		{{- end}} {{/* range $operationsGroupByPattern */}}
	}
}

func getDefinitions(schema oasv2.Schema) map[string]oasv2.Definition {
	defs := make(map[string]oasv2.Definition)

	{{range .Spec.Operations -}}

	{{- $nonCtxParams := nonCtxParams .Request.Params}}
	{{- $bodyParams := bodyParams $nonCtxParams}}
	{{- $bodyField := getBodyField .Request.BodyField}}
	{{- if $bodyField}}
	oasv2.AddDefinition(defs, "{{.Name}}RequestBody", reflect.ValueOf(({{addAmpersand .Name}}Request{}).{{title $bodyField}}))
	{{- else if $bodyParams}}
	oasv2.AddDefinition(defs, "{{.Name}}RequestBody", reflect.ValueOf(&struct{
		{{- range $bodyParams}}
		{{title .Name}} {{.Type}} {{addTag .Alias .Type}}
		{{- end}} {{/* range $bodyParams */}}
	}{}))
	{{- end}} {{/* if $bodyField */}}
	oasv2.AddResponseDefinitions(defs, schema, "{{.Name}}", {{.SuccessResponse.StatusCode}}, ({{addAmpersand .Name}}Response{}).Body())

    {{end -}} {{/* range .Spec.Operations */}}

	return defs
}

func OASv2APIDoc(schema oasv2.Schema) string {
	resps := getResponses(schema)
	paths := oasv2.GenPaths(resps, paths)

	defs := getDefinitions(schema)
	definitions := oasv2.GenDefinitions(defs)

	return base + paths + definitions
}
`
)

type Options struct {
	SchemaPtr         bool
	SchemaTag         string
	TagKeyToSnakeCase bool
	Formatted         bool
}

type Generator struct {
	opts *Options
}

func New(opts *Options) *Generator {
	return &Generator{opts: opts}
}

func (g *Generator) Generate(result *reflector.Result, spec *openapi.Specification) ([]byte, error) {
	data := struct {
		Result *reflector.Result
		Spec   *openapi.Specification
	}{
		Result: result,
		Spec:   spec,
	}

	type OperationsPerPattern struct {
		Pattern    string
		Operations []*openapi.Operation
	}

	type ParamType struct {
		Type     string
		ItemType string
	}

	return generator.Generate(template, data, generator.Options{
		Funcs: map[string]interface{}{
			"title": strings.Title,
			"lower": strings.ToLower,
			"operationsGroupByPattern": func(ops []*openapi.Operation) (outOps []*OperationsPerPattern) {
				var opp *OperationsPerPattern
				var ok bool

				patternToOps := make(map[string]*OperationsPerPattern)

				for _, op := range ops {
					opp, ok = patternToOps[op.Pattern]
					if !ok {
						opp = &OperationsPerPattern{Pattern: op.Pattern}
						outOps = append(outOps, opp)
						patternToOps[op.Pattern] = opp
					}
					opp.Operations = append(opp.Operations, op)
				}

				return
			},
			"typeName": func(typ string) ParamType {
				basicOASType := func(n string) string {
					switch n {
					case "int", "int8", "int16", "int32", "int64",
						"uint", "uint8", "uint16", "uint32", "uint64":
						return "integer"
					case "float32", "float64":
						return "number"
					case "string":
						return "string"
					case "bool":
						return "boolean"
					default:
						return "string"
					}
				}

				isBasicGoType := func(t string) bool {
					switch t {
					case "bool", "string",
						"int", "int8", "int16", "int32", "int64",
						"uint", "uint8", "uint16", "uint32", "uint64",
						"float32", "float64":
						return true
					default:
						return false
					}
				}

				// Cases are more complicated regarding Argument aggregation,
				// where typ (as the same as argument type) usually does not
				// match the actual type of the corresponding request parameter.
				//
				// | Method argument | Request parameter    |
				// | --------------- | -------------------- |
				// | basic or slice  | string (UNSUPPORTED) |
				// | struct or other | string               |
				//
				// Adding one more optional tag `type` in the @kok(param)
				// annotation may be a better solution?

				switch {
				case isBasicGoType(typ):
					return ParamType{Type: basicOASType(typ)}
				case strings.HasPrefix(typ, "[]") && isBasicGoType(typ[2:]):
					itemType := typ[2:]
					return ParamType{Type: "array", ItemType: basicOASType(itemType)}
				default:
					return ParamType{Type: "string"}
				}
			},
			"getTags": func(opTags, defaultTags []string) []string {
				if len(opTags) > 0 {
					return opTags
				}
				return defaultTags
			},
			"nonCtxParams": func(params []*openapi.Param) (out []*openapi.Param) {
				for _, p := range params {
					if p.Type != "context.Context" && p.In != openapi.InRequest {
						// Parameters in `request` have no relationship with OAS.
						out = append(out, p)
					}
				}
				return
			},
			"nonBodyParams": func(in []*openapi.Param) (out []*openapi.Param) {
				for _, p := range in {
					if p.In != openapi.InBody {
						out = append(out, p)
					}
				}
				return
			},
			"bodyParams": func(in []*openapi.Param) (out []*openapi.Param) {
				for _, p := range in {
					if p.In == openapi.InBody {
						out = append(out, p)
					}
				}
				return
			},
			"addAmpersand": func(name string) string {
				if g.opts.SchemaPtr {
					return "&" + name
				}
				return name
			},
			"addTag": func(name, typ string) string {
				if g.opts.SchemaTag == "" {
					return ""
				}

				if typ == "error" {
					name = "-"
				} else if g.opts.TagKeyToSnakeCase {
					name = caseconv.ToSnakeCase(name)
				}

				return fmt.Sprintf("`%s:\"%s\"`", g.opts.SchemaTag, name)
			},
			"getBodyField": func(name string) string {
				if name != "" && name != openapi.OptionNoBody {
					return name
				}
				return ""
			},
		},
		Formatted: g.opts.Formatted,
	})
}
